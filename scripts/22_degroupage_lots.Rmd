---
title: "ASPE - Dégroupage des lots S/L"
author: "Pascal Irz"
date: "`r format(Sys.time(), 'Le %d %B %Y')`"
output:
  html_document:
    code_folding: hide
    toc: true
    toc_float: true    
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
options(knitr.kable.NA = '---')
```

# Introduction

La base de données Aspe contient des données de longueurs individuelles des poissons. Il est fastidieux de mesurer ces longueurs quand les effectifs sont importants, typiquement pour les $0^+$. Dans ces cas, on procède sur le terrain en regroupant les poissons par lots (=groupes de poissons d'une mêm espèce et de taille réputée homogène). Dans le cas du "lot de groupe avec sous-échantillon", seul un sous-échantillon fait l'objet de mesures individuelles.

# Objectif

Il s'agit ici d'examiner si l'algorithme de la base Aspe qui - sur la base du sous-échantillon mesuré - affecte des longueurs (tailles) aux individus non mesurés du même lot donne des résultats satisfaisants.

# Chargement packages et données

```{r, eval = FALSE}
library(aspe)
library(aspeQual)
library(tidyverse)
library(kableExtra)

load(file = "raw_data/tables_sauf_mei_2021_10_21_11_44_01.RData")
load(file = "raw_data/mei_2021_10_21_11_44_01.RData")
```

```{r, echo = FALSE, warning = FALSE, message = FALSE}
library(aspe)
library(aspeQual)
library(tidyverse)
library(kableExtra)

rdata_tables <- misc_nom_dernier_fichier(repertoire = "../../../raw_data",
                                         pattern = "^tables")

rdata_mei <- misc_nom_dernier_fichier(repertoire = "../../../raw_data",
                                      pattern = "^mei")

load(rdata_tables)
load(rdata_mei)

rm(data_tables, rdata_mei)
```


## Assemblage du jeu de données

Pour constituer le jeu de données, les étapes sont :

- Création d'une table "passerelle" mettant en correspondance les sites, opérations, etc.   
- Ajout des lots de poissons et de leur type
- Ajout du type de longueur
- Remplacement des codes espèces internes de la base par les codes à trois lettres   
- Ajout des mesures individuelles pour ne conserver que les mesures réelles et positives de longueur et masse   
- Sélection des variables à conserver et dédoublonnage   


```{r}
data <- mef_creer_passerelle() %>% 
  mef_ajouter_lots() %>% 
  mef_ajouter_type_lot() %>% 
  mef_ajouter_mei() %>% 
  filter(mei_taille > 0) %>% # longueur positive
  mef_ajouter_libelle() %>% 
  mef_ajouter_ope_date() %>% 
  select(mei_id,
         lop_id,
         ope_id,
         tyl_libelle,
         pop_libelle,
         annee,
         mei_taille,
         mei_poids,
         mei_mesure_reelle,
         esp_code_alternatif) %>% 
  left_join(ref_espece %>%
              select(esp_code_alternatif,
                     esp_nom_commun))
```

Les premières lignes du tableau :

```{r}
data %>% 
  head() %>% 
  DT::datatable()
```

# Description des données

```{r}
ref_type_lot %>% 
  select(tyl_libelle, tyl_libelle_sandre) %>% 
  DT::datatable(rownames = F,
                options = list(dom = 't'))
```

Nombre d'individus selon le type de lot, et selon que la mesure a été réellement effectuée (mei_mesure_reelle = t) ou qu'il s'agit d'une longueur produite par l'algorithme de dégroupage :

```{r}
data %>% 
  group_by(tyl_libelle,
           mei_mesure_reelle) %>% 
  tally() %>% 
  pivot_wider(names_from = mei_mesure_reelle,
              values_from = n) %>% 
  knitr::kable(format.args = list(big.mark = " ",
                                  scientific = FALSE),
               col.names = c("Type de lot",
                             "Dégroupages",
                             "Longueurs mesurées")) %>% 
  kable_paper("hover", full_width = T)
```


On a donc du dégroupage dans les lots "G" et "S/L".

# Dégroupage lots S/L

## Les données de la base

### Préparation des données

On va comparer les distributions des longueurs, sur un même lot, entre individus mesurés réellement (`mei_mesure_reelle = "t")` et individus dégroupés (`mei_mesure_reelle = "f")`. Pour que ça ait un sens, la comparaison sera effectuée sur les lots comprenant au moins 30 individus mesurés individuellement et 30 individus "dégroupés". On va donc commencer par compter ces deux groupes pour chacun des lots "S/L".

```{r}
comptage <- data %>%
  filter(tyl_libelle == "S/L") %>% 
  group_by(esp_code_alternatif,
           lop_id,
           mei_mesure_reelle) %>% 
    tally() %>% 
  ungroup() %>% 
  pivot_wider(names_from = mei_mesure_reelle,
              values_from = n)
```

Extrait du tableau :

```{r, fig.align = 'center'}
comptage %>% 
  sample_n(10) %>% 
  DT::datatable(rownames = FALSE,
                width = 5,
                options = list(dom = 't'))
```

Sélection des lots comptant suffisamment d'individus :

```{r}
mes_lots <- comptage %>% 
  filter(f > 29, t > 29) %>% 
  pull(lop_id)
```


Elimination des lots insuffisants (et suppression des parties entre parenthèses dans les noms de stations pour les raccourcir).

```{r}
data_lots <- data %>% 
  filter(lop_id %in% mes_lots) %>% 
  mutate(pop_libelle = str_replace(pop_libelle,
                                   pattern = " \\s*\\([^\\)]+\\)",
                                   replacement = ""))
```


### Exemples graphiques

```{r}
n_lots <- 12 # choix du nb de graphiques pour le "top"
```


On peut représenter graphiquement les lots comptant le plus d'individus mesurés, en comparant les distributions entre ces individus et ceux dont la longueur a été estimée. Si l'algorithme d'estimation n'est pas biaisé, les distributions doivent se ressembler.

Sélection d'un "top" des lots, ceux avec le plus d'individus mesurés (n = `r n_lots` lots).

```{r}
top_lots <- comptage %>%
  filter(lop_id %in% mes_lots) %>% 
  arrange(-t, -f) %>%
  filter(!is.na(f)) %>%
  slice(1:n_lots) %>%
  pull(lop_id)

top_lots_data <- data_lots %>%
  filter(lop_id %in% top_lots)
```

Production des graphiques

```{r, echo = F, include = FALSE}
graphiques <- map(.x = top_lots,
                  .f = qta_densite_comp_distri_lot,
                  df = top_lots_data,
                  variable = "mei_taille")
```


Assemblage des graphiques

```{r, fig.height = n_lots, fig.width = 10}
qta_densite_comp_distri_lot_grille(liste_graphiques = graphiques,
                                   ncol = 3,
                                   nrow = 4)
```

>Les moyennes sont plutôt proches, cependant il apparaît assez clairement que les dispersions peuvent différer nettement. Les cas de bimodalité des valeurs mesurées ne se retrouvent pas lors du dégroupage.

## Proposition d'algorithme de dégroupage alternatif

### Principe

On peut remplacer l'algorithme employé par la base par un simple tirage aléatoire parmi les poissons mesurés. L'avantage est de ne pas comporter d'hypothèse quant à la distribution des données de longueur.

### Calcul

On rajoute au tableau de données une colonne `mei_taille_alt` avec des mesures de longueur complétées selon a règle suivante :

- si l'individu a été réellement mesuré, on reprend cette mesure dans le champ `mei_taille`
- si l'individu n'a pas été mesuré (dégroupage), on prend la longueur d'un individu tiré aléatoirement parmi le sous-lot mesuré

```{r}
top_lots_data <- top_lots_data %>% 
  qta_ajouter_mei_taille_alt()
```

### Comparaison graphique

```{r, echo = F, include = FALSE}
graphiques_ta <- map(.x = top_lots,
                     .f = qta_densite_comp_distri_lot,
                     df = top_lots_data,
                     variable = "mei_taille_alt")
```

On peut mettre côte à côte pour chacun des lots les graphiques issus du dégroupage actuel Aspe (colonne de gauche) et du dégroupage alternatif (colonne de droite).

```{r}
# assemblage des deux listes de graphiques en une seule
graphiques_tot <- list(graphiques, graphiques_ta) %>% 
  unlist(recursive = FALSE)

# ordonancement des graphiques pour mettre en vis-a-vis les deux graphiques correspondant
# à un même lot. Par ex si 10 lots, on a 2 séries selon la méthode de dégroupage 
# => total 20 graphiques qu'on veut ordonner dans l'ordre 1, 11, 2, 12, 3, 13 ...
indices <- rbind(1:n_lots, (1 + n_lots):(2 * n_lots)) %>% c()

graphiques_tot <- graphiques_tot[indices]
```

```{r, fig.height = 2.5 * n_lots, fig.width = 9}
qta_densite_comp_distri_lot_grille(liste_graphiques = graphiques_tot,
                                   ncol = 2,
                                   nrow = n_lots)
```

>Il apparaît graphiquement que les écarts entre les distributions mesurées et dégroupées sont moindres avec la méthode alternative. Particulièrement quand le lot n'est pas vraiment unimodal.

### Comparaison statistique

Il s'agit ici d'évaluer laquelle des deux méthodes de dégroupage est la plus fidèle à la distribution de départ sur les individus réellement mesurés. On compare donc chacune des méthodes de dégroupage avec le distribution de départ en testant :

- La similarité des distributions par un test non paramétrique de Kolmogorov-Smirnov
- L'égalité des moyennes par un test de Student
- L'égalité des variances par un test F

L'opération est réalisée sur les mêmes lots que les graphiques ci-dessus.



```{r}
# tests sur les données dégroupées par Aspe
degroupage_aspe <- map(
  .x = top_lots,
  .f = qta_tests_1lot_1var,
  df = top_lots_data,
  variable = "mei_taille"
) %>%
  reduce(rbind)

# tests sur les données par le dégroupage alternatif
degroupage_alt <- map(
  .x = top_lots,
  .f = qta_tests_1lot_1var,
  df = top_lots_data,
  variable = "mei_taille_alt"
) %>%
  reduce(rbind)

# assemblage
degroupage <- degroupage_aspe %>%
  cbind(degroupage_alt %>%
          select(
            ta_ks = ks,
            ta_student = student,
            ta_variance = variance
          ))

# mise en forme
tests_sig <- degroupage %>%
  mutate_at(vars(ks:ta_variance),
            function(x) {
              x <- case_when(x < 1e-3 ~ "(***)",
                             x < 1e-2 ~ "(**)",
                             x < 0.05 ~ "(*)",
                             TRUE ~ NA_character_)
            })

# presentation du tableau
tests_sig %>%
  kbl(
    col.names = c(
      'lop_id',
      'Station',
      'Espèce',
      'Effectif mesuré',
      'Effectif non mesuré',
      'Distributions',
      'Moyennes',
      'Variances',
      'Distributions',
      'Moyennes',
      'Variances'
    ),
    align = c('r', 'l', 'l', 'r', 'r', rep('c', 6)),
    linesep = ""
  ) %>%
  kableExtra::kable_paper() %>%
  kableExtra::column_spec(column = 6:11,
                          background = "grey10") %>%
  kableExtra::add_header_above(c(
    " " = 5,
    "Dégroupage Aspe" = 3,
    "Tirage aléatoire" = 3
  ))
```

>Le dégroupage par Aspe distord fortement les distributions et leurs variances. Les moyennes sont sensiblement moins impactées. En comparaison, la méthode alternative semble plus satisfaisante.

## Impact sur les distributions des populations

On examine ici l'éventuelle influence de la méthode de dégroupage sur la distribution en longueur de la population au moment d'une opération d'achantillonnage, en gardant l'exemple des pêches correspondant `r n_lots` lots ci-dessus.

A partir du jeu de données complet, on filtre pour ne conserver que les opérations et espèces qui nous intéressent.

```{r}
mes_populations <- data %>%
  filter(lop_id %in% top_lots) %>%
  select(ope_id, esp_code_alternatif) %>%
  distinct()

data_populations <- mes_populations %>%
  left_join(data) %>%
  aspeQual::qta_ajouter_mei_taille_alt() %>%
  select(
    ope_id,
    mei_id,
    pop_libelle,
    esp_nom_commun,
    annee,
    mei_mesure_reelle,
    mei_taille,
    mei_taille_alt
  ) %>% 
pivot_longer(cols = mei_taille:mei_taille_alt,
             names_to = "degroupage",
             values_to = "taille")
```

```{r}
qta_densite_comp_distri_lot(df = data_populations,
                            id_lot = )
```

