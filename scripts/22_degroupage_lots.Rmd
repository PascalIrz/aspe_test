---
title: "ASPE - Dégroupage des lots"
author: "Pascal Irz"
date: "`r format(Sys.time(), 'Le %d %B %Y')`"
output:
  html_document:
    code_folding: hide
    toc: true
    toc_float: true    
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
set.seed(seed = 12345)
```

# Introduction

La base de données Aspe contient des données de longueurs individuelles des poissons. Il est fastidieux de mesurer ces longueurs quand les effectifs sont importants, typiquement pour les $0^+$. Dans ces cas, on procède en regroupant les poissons par lots 

# Objectif

# Chargement packages et données

```{r, eval = FALSE}
library(aspe)
library(tidyverse)

load(file = "raw_data/tables_sauf_mei_2021_10_21_11_44_01.RData")
load(file = "raw_data/mei_2021_10_21_11_44_01.RData")
```

```{r, echo = FALSE, warning = FALSE, message = FALSE}
library(aspe)
library(tidyverse)

rdata_tables <- misc_nom_dernier_fichier(repertoire = "../../../raw_data",
                                         pattern = "^tables")

rdata_mei <- misc_nom_dernier_fichier(repertoire = "../../../raw_data",
                                      pattern = "^mei")

load(rdata_tables)
load(rdata_mei)

rm(data_tables, rdata_mei)
```


## Assemblage du jeu de données

Pour constituer le jeu de données, les étapes sont :

- Création d'une table "passerelle" mettant en correspondance les sites, opérations, etc.   
- Ajout des lots de poissons et de leur type
- Ajout du type de longueur
- Remplacement des codes espèces internes de la base par les codes à trois lettres   
- Ajout des mesures individuelles pour ne conserver que les mesures réelles et positives de longueur et masse   
- Sélection des variables à conserver et dédoublonnage   


```{r}
data <- mef_creer_passerelle() %>% 
  mef_ajouter_lots() %>% 
  mef_ajouter_type_lot() %>% 
  mef_ajouter_mei() %>% 
  filter(mei_taille > 0) %>% # longueur positive
  mef_ajouter_libelle() %>% 
  mef_ajouter_ope_date() %>% 
  select(mei_id,
         lop_id,
         tyl_libelle,
         pop_libelle,
         annee,
         mei_taille,
         mei_poids,
         mei_mesure_reelle,
         esp_code_alternatif) %>% 
  left_join(ref_espece %>%
              select(esp_code_alternatif, esp_nom_commun))
```

Les premières lignes du tableau :

```{r}
data %>% 
  head() %>% 
  DT::datatable()
```

# Description des données

```{r}
ref_type_lot %>% 
  select(tyl_libelle, tyl_libelle_sandre) %>% 
  DT::datatable(rownames = F)
```

Nombre d'individus selon le type de lot, et selon que la mesure a été réellement effectuée (mei_mesure_reelle = t) ou qu'il s'agit d'une longueur produite par l'algorithme de dégroupage :

```{r}
data %>% 
  group_by(tyl_libelle, mei_mesure_reelle) %>% 
  tally() %>% 
  pivot_wider(names_from = mei_mesure_reelle,
              values_from = n) %>% 
  knitr::kable(format.args = list(big.mark = " ",
                                  scientific = FALSE),
               col.names = c("Type de lot", "Longueur par dégroupage", "Longueur mesurée"))
```


On a donc du dégroupage dans les lots "G" et "S/L".

# Dégroupage lots S/L

## Les données de la base

### Préparation des données

On va comparer les distributions des longueurs, sur un même lot, entre individus mesurés réellement et individus dégroupés. Pour que ça ait un sens, la comparaison sera effectuée sur les lots comprenant au moins 30 individus mesurés individuellement et 30 individus "dégroupés". On va donc commencer par compter ces deux groupes pour chacun des lots "S/L".

```{r}
comptage <- data %>%
  filter(tyl_libelle == "S/L") %>% 
  group_by(esp_code_alternatif,
           lop_id,
           mei_mesure_reelle) %>% 
    tally() %>% 
  ungroup() %>% 
  pivot_wider(names_from = mei_mesure_reelle,
              values_from = n)
```


Sélection des lots comptant suffisamment d'individus :

```{r}
mes_lots <- comptage %>% 
  filter(f > 29, t > 29) %>% 
  pull(lop_id)
```


Elimination des lots insuffisants (et suppression des parties entre parenthèses dans les noms de stations pour les raccourcir).

```{r}
data <- data %>% 
  filter(lop_id %in% mes_lots) %>% 
  mutate(pop_libelle = str_replace(pop_libelle,
                                   pattern = " \\s*\\([^\\)]+\\)",
                                   replacement = ""))
```


### Exemples

On peut représenter graphiquement les lots comptant le plus d'individus mesurés, en comparant les distributions entre ces individus et ceux dont la longueur a été estimée. Si l'algorithme d'estimation n'est pas biaisé, les distributions doivent se ressembler.

```{r}
gg_comp_distri_lot <- function(data, id_lot, variable)
  
  {
lot_data <- data %>% 
  filter(lop_id == id_lot)

mes_stats <- lot_data %>% 
  group_by(mei_mesure_reelle) %>% 
    summarise(moy = mean(get(variable)),
              effectif = n())

sous_titre <- lot_data %>%
  slice(1) %>%
  select(pop_libelle, annee) %>% 
  paste(collapse = " - ")

titre <- paste0("Lot n°",
                lot_data %>% 
                  slice(1) %>% 
                  select(lop_id, esp_nom_commun) %>% 
                  paste(collapse = " - "))

texte <- mes_stats %>% pull(effectif)
texte <- paste0("n=", texte)

mon_grob <- grid::grid.text(label = texte,
                            x = c(0.80, 0.80),
                            y = c(0.88, 0.95),
                            just = "left",
                            gp = grid::gpar(col = RColorBrewer::brewer.pal(n = 2,
                                                                           name = "Dark2"),
                                            fontsize = 8))

ggplot(data = lot_data,
       aes(x = get(variable),
               fill = mei_mesure_reelle,
               col = mei_mesure_reelle)) +
  geom_density(alpha = 0.2) +
  geom_vline(data = mes_stats,
             aes(xintercept = moy,
                 col = mei_mesure_reelle)) +
  labs(x = "",
       y = "",
       fill = "Longueur obtenue par",
       col = "Longueur",
       title = titre,
       subtitle = sous_titre) +
  theme(plot.title = element_text(size = 10),
        plot.subtitle = element_text(size = 8),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  scale_fill_brewer(palette = "Dark2", labels = c("Dégroupage", "Mesure")) +
  scale_color_brewer(palette = "Dark2", labels = c("Dégroupage", "Mesure")) +
  annotation_custom(mon_grob)

}
```

Sélection d'un "top" des lots

```{r}
top_lots <- comptage %>%
  filter(lop_id %in% mes_lots) %>% 
  arrange(-t, -f) %>%
  filter(!is.na(f)) %>%
  slice(1:30) %>%
  pull(lop_id)

top_lots_data <- data %>%
  filter(lop_id %in% top_lots)
```

Production des graphiques

```{r, echo = F, include = FALSE}

gg_comp_distri_lot_treillis <- function(liste_graphiques, ncol, nrow) 
  
{

 fig <- ggpubr::ggarrange(
  plotlist = liste_graphiques,
  ncol = ncol,
  nrow = nrow,
  common.legend = TRUE,
  legend = "top")
  
  ggpubr::annotate_figure(
  fig,
  bottom = ggpubr::text_grob("Longueur (mm)"),
  left = ggpubr::text_grob("Densité", rot = 90
  )
)
  
}

```


```{r, echo = F, include = FALSE}
graphiques <- map(.x = top_lots,
                  .f = gg_comp_distri_lot,
                  data = top_lots_data,
                  variable = "mei_taille")
```

Assemblage des graphiques

```{r, fig.height = 30, fig.width=9}
gg_comp_distri_lot_treillis(liste_graphiques = graphiques,
                            ncol = 3,
                            nrow = 10)
```

>Il apparaît assez clair que les moyennes sont proches, cependant les dispersions peuvent différer nettement. Les cas de bimodalité des valeurs mesurées ne se retrouvent pas lors du dégroupage.

## Proposition d'algorithme de dégroupage alternatif

On peut remplacer l'algorithme employé par la base par un simple tirage aléatoire parmi les poissons mesurés.

```{r}
ajouter_mei_taille_ta <- function(df)
  
{
  mes_lots <- df %>%
    pull(lop_id) %>%
    unique()
  
  # fonction qui ajoute au df d'un lot la colonne mei_taille_ta qui, quand mei_mesure_reelle == "f",
  # tire aléatoirement une valeur parmi les mei_mesure_reelle == "t" du même lot.
  ajouter_mei_taille_ta_1_lot <- function(df, id_lot) {
    data_1lot <- df %>%
      filter(lop_id == id_lot)
    
    data_1lot_t <- data_1lot %>%
      filter(mei_mesure_reelle == "t") %>%
      mutate(mei_taille_ta = mei_taille)
    
    data_1lot_f <- data_1lot %>%
      filter(mei_mesure_reelle == "f")
    
    data_1lot_f$mei_taille_ta <- sample(
      x = data_1lot_t$mei_taille,
      size = nrow(data_1lot_f),
      replace = TRUE
    )
    
    data_1lot_ta <- rbind(data_1lot_t, data_1lot_f)
    
    data_1lot_ta
    
  }
  # application sur l'ensemble des lots du df
  map(.x = mes_lots,
      .f = ajouter_mei_taille_ta_1_lot,
      df = top_lots_data) %>%
    reduce(rbind)
}

```

```{r}
top_lots_data <- top_lots_data %>% 
  ajouter_mei_taille_ta()
```

```{r, echo = F, include = FALSE}
graphiques_ta <- map(.x = top_lots,
                     .f = gg_comp_distri_lot,
                     data = top_lots_data,
                     variable = "mei_taille_ta")
```

Assemblage des graphiques

```{r, fig.height = 30, fig.width = 9}
gg_comp_distri_lot_treillis(liste_graphiques = graphiques_ta,
                            ncol = 3,
                            nrow = 10)
```

On peut mettre côte à côte pour chacun des lots les graphiques issus du dégroupage actuel (colonne de gauche) et du dégroupage par tirage aléatoire (colonne de droite).

```{r}
# ordonancement des graphiques
graphiques_tot <- list(graphiques, graphiques_ta) %>% 
  unlist(recursive = FALSE)

indices <- 1:60
i <- list()
for (indice in 1:30) {
  bival <- c(indices[indice], indices[indice+30])
  i <- c(i, bival)
}
i <- unlist(i)

graphiques_tot <-graphiques_tot[i]
```

```{r, fig.height = 90, fig.width = 9}
gg_comp_distri_lot_treillis(liste_graphiques = graphiques_tot,
                            ncol = 2,
                            nrow = 30)
```

```{r}
#mon_lot <- top_lots_data$lop_id[1]

mes_tests_1lot_1var <- function(df, id_lot, variable)
  
{
  
  lot_data <- df %>% 
    filter(lop_id == id_lot)

  t <- lot_data %>% 
    filter(mei_mesure_reelle == "t") %>% 
    pull(get(variable))

  f <- lot_data %>% 
    filter(mei_mesure_reelle == "f") %>% 
    pull(get(variable))

  ks <- ks.test(t, f) %>% 
  .$p.value

  student <- t.test(t, f) %>% 
  .$p.value

  variance <- var.test(t, f) %>% 
  .$p.value

  nt <- lot_data %>% 
    filter(mei_mesure_reelle == "t") %>% 
    nrow()

  nf <- nrow(lot_data) - nt
  
  lop_id <- id_lot
  
  station = lot_data$pop_libelle[1]
  
  espece = lot_data$esp_nom_commun[1]

  data.frame(station, espece, lop_id, nt, nf, ks, student, variance)

}

# mes_tests_1lot_1var(df = top_lots_data,
#                     id_lot = mon_lot,
#                     variable = "mei_taille_ta")

degr_aspe <- map(.x = top_lots,
    .f = mes_tests_1lot_1var,
    df = top_lots_data,
    variable = "mei_taille") %>% 
  reduce(rbind)

degr_ta <- map(.x = top_lots,
    .f = mes_tests_1lot_1var,
    df = top_lots_data,
    variable = "mei_taille_ta") %>% 
  reduce(rbind)

degr <- degr_aspe %>% 
  cbind(degr_ta %>% 
          select(ta_ks = ks,
                 ta_student = student,
                 ta_variance = variance))

tests_sig <- degr %>% 
  mutate_at(vars(ks:ta_variance),
            function(x) {x <- case_when(x < 1e-3 ~ "***",
                                        x < 1e-2 ~ "**",
                                        x < 0.05 ~ " * ",
                    #                    x < 0.1 ~ " . ",
                                        TRUE ~ NA_character_)})

kableExtra::kbl(tests_sig,
                align = c('l', 'l', 'r', 'r', 'r', rep('c', 6))) %>%
  kableExtra::kable_paper() %>%
  kableExtra::add_header_above(c(" " = 5, "Dégroupage Aspe" = 3, "Tirage aléatoire" = 3))
```

