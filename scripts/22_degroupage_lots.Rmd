---
title: "ASPE - Dégroupage des lots"
author: "Pascal Irz"
date: "`r format(Sys.time(), 'Le %d %B %Y')`"
output:
  html_document:
    code_folding: hide
    toc: true
    toc_float: true    
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

# Introduction

La base de données Aspe contient des données de longueurs individuelles des poissons. Il est fastidieux de mesurer ces longueurs quand les effectifs sont importants, typiquement pour les $0^+$. Dans ces cas, on procède en regroupant les poissons par lots 

# Objectif

# Chargement packages et données

```{r, eval = FALSE}
library(aspe)
library(tidyverse)

load(file = "raw_data/tables_sauf_mei_2021_10_21_11_44_01.RData")
load(file = "raw_data/mei_2021_10_21_11_44_01.RData")
```

```{r, echo = FALSE, warning = FALSE, message = FALSE}
library(aspe)
library(tidyverse)

rdata_tables <- misc_nom_dernier_fichier(repertoire = "../../../raw_data",
                                         pattern = "^tables")

rdata_mei <- misc_nom_dernier_fichier(repertoire = "../../../raw_data",
                                      pattern = "^mei")

load(rdata_tables)
load(rdata_mei)

rm(data_tables, rdata_mei)
```


## Assemblage du jeu de données

Pour constituer le jeu de données, les étapes sont :

- Création d'une table "passerelle" mettant en correspondance les sites, opérations, etc.   
- Ajout des lots de poissons et de leur type
- Ajout du type de longueur
- Remplacement des codes espèces internes de la base par les codes à trois lettres   
- Ajout des mesures individuelles pour ne conserver que les mesures réelles et positives de longueur et masse   
- Sélection des variables à conserver et dédoublonnage   


```{r}
data <- mef_creer_passerelle() %>% 
  mef_ajouter_lots() %>% 
  mef_ajouter_type_lot() %>% 
  mef_ajouter_mei() %>% 
  filter(mei_taille > 0) %>% # longueur positive
  mef_ajouter_libelle() %>% 
  mef_ajouter_ope_date() %>% 
  select(mei_id,
         lop_id,
         tyl_libelle,
         pop_libelle,
         annee,
         mei_taille,
         mei_poids,
         mei_mesure_reelle,
         esp_code_alternatif) %>% 
  left_join(ref_espece %>%
              select(esp_code_alternatif, esp_nom_commun))
```

Les premières lignes du tableau :

```{r}
data %>% 
  head() %>% 
  DT::datatable()
```

# Description des données

```{r}
ref_type_lot %>% 
  select(tyl_libelle, tyl_libelle_sandre) %>% 
  DT::datatable(rownames = F)
```

Nombre d'individus selon le type de lot, et selon que la mesure a été réellement effectuée (mei_mesure_reelle = t) ou qu'il s'agit d'une longueur produite par l'algorithme de dégroupage :

```{r}
data %>% 
  group_by(tyl_libelle, mei_mesure_reelle) %>% 
  tally() %>% 
  pivot_wider(names_from = mei_mesure_reelle,
              values_from = n) %>% 
  knitr::kable(format.args = list(big.mark = " ",
                                  scientific = FALSE),
               col.names = c("Type de lot", "Longueur par dégroupage", "Longueur mesurée"))
```


On a donc du dégroupage dans les lots "G" et "S/L".

# Dégroupage lots S/L

## Les données de la base

### Préparation des données

On va comparer les distributions des longueurs, sur un même lot, entre individus mesurés réellement et individus dégroupés. Pour que ça ait un sens, la comparaison sera effectuée sur les lots comprenant au moins 30 individus mesurés individuellement et 30 individus "dégroupés". On va donc commencer par compter ces deux groupes pour chacun des lots "S/L".

```{r}
comptage <- data %>%
  filter(tyl_libelle == "S/L") %>% 
  group_by(esp_code_alternatif,
           lop_id,
           mei_mesure_reelle) %>% 
    tally() %>% 
  ungroup() %>% 
  pivot_wider(names_from = mei_mesure_reelle,
              values_from = n)
```


Sélection des lots comptant suffisamment d'individus :

```{r}
mes_lots <- comptage %>% 
  filter(f > 29, t > 29) %>% 
  pull(lop_id)
```


Elimination des lots insuffisants (et suppression des parties entre parenthèses dans les noms de stations pour les raccourcir).

```{r}
data <- data %>% 
  filter(lop_id %in% mes_lots) %>% 
  mutate(pop_libelle = str_replace(pop_libelle,
                                   pattern = " \\s*\\([^\\)]+\\)",
                                   replacement = ""))
```


## Exemples

On peut représenter graphiquement les lots comptant le plus d'individus mesurés, en comparant les distributions entre ces individus et ceux dont la longueur a été estimée. Si l'algorithme d'estimation n'est pas biaisé, les distributions doivent se ressembler.

```{r}
gg_comp_distri_lot <- function(data, id_lot)
{
lot_data <- data %>% 
  filter(lop_id == id_lot)

mes_stats <- lot_data %>% 
  group_by(mei_mesure_reelle) %>% 
    summarise(moy = mean(mei_taille),
              effectif = n())

sous_titre <- lot_data %>%
  slice(1) %>%
  select(pop_libelle, annee) %>% 
  paste(collapse = " - ")

titre <- paste0("Lot n°",
                lot_data %>% 
                  slice(1) %>% 
                  select(lop_id, esp_nom_commun) %>% 
                  paste(collapse = " - "))

texte <- mes_stats %>% pull(effectif)
texte <- paste0("n=", texte)

mon_grob <- grid::grid.text(label = texte,
                            x = c(0.80, 0.80),
                            y = c(0.88, 0.95),
                            just = "left",
                            gp = grid::gpar(col = RColorBrewer::brewer.pal(n = 2,
                                                                           name = "Dark2"),
                                            fontsize = 8))

ggplot(data = lot_data,
       aes(x = mei_taille,
               fill = mei_mesure_reelle,
               col = mei_mesure_reelle)) +
  geom_density(alpha = 0.2) +
  geom_vline(data = mes_stats,
             aes(xintercept = moy,
                 col = mei_mesure_reelle)) +
  labs(x = "",
       y = "",
       title = titre,
       subtitle = sous_titre) +
  theme(plot.title = element_text(size = 10),
        plot.subtitle = element_text(size = 8),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  scale_fill_brewer(palette = "Dark2") +
  scale_color_brewer(palette = "Dark2") +
  annotation_custom(mon_grob)

}
```

Sélection d'un "top" des lots

```{r}
top_lots <- comptage %>%
  filter(lop_id %in% mes_lots) %>% 
  arrange(-t, -f) %>%
  filter(!is.na(f)) %>%
  slice(1:30) %>%
  pull(lop_id)

top_lots_data <- data %>%
  filter(lop_id %in% top_lots)
```

Production des graphiques

```{r, echo = F, include = FALSE}
graphiques <- map(.x = top_lots,
                  .f = gg_comp_distri_lot,
                  data = top_lots_data)
```

Assemblage des graphiques

```{r, fig.height = 30, fig.width=9}
fig <- ggpubr::ggarrange(
  plotlist = graphiques,
  ncol = 3,
  nrow = 10,
  common.legend = TRUE,
  legend = "top"
)

ggpubr::annotate_figure(
  fig,
  bottom = ggpubr::text_grob("Longueur (mm)"),
  left = ggpubr::text_grob("Densité", rot = 90
  )
)
```

>Il apparaît assez clair que les moyennes sont proches, cependant les dispersions peuvent différer nettement. Les cas de bimodalité des valeurs mesurées ne se retrouvent pas lors du dégroupage.

