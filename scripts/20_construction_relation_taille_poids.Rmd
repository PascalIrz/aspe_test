---
title: "ASPE - Construire des relations taille-poids"
author: "Pascal Irz"
date: "`r format(Sys.time(), 'Le %d %B %Y')`"
output:
  html_document:
    code_folding: show
    toc: true
    toc_float: true    
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

# Objectif

Ce document donne un exemple de chaîne de traitement des données Aspe pour produire des relations taille - poids.

Ces relations se veulent aussi générales que possible, donc on veillera à ce que des observations atypiques, voire des erreurs dans la base de données, ne viennent pas les influencer exagérément. La dernière partie montre comment confronter les résultats issus de Aspe à ceux publiés dans la littérature et diffusés par la base en ligne [Fishbase](www.fishbase.se).

Il suppose que le package `aspe` a été installé et que les opérations d'importation depuis le `dump` ont été effectuées et les `dataframe` sauvegardés au format `.RData` (sinon se reporter au [tuto dédié à ces étapes](https://rpubs.com/kamoke/713407)).

Les fonctions du package `aspe` dédiées à ces traitements sont identifiées par le préfixe `qtp_`, pour "Qualité Taille Poids" car l'usage premier de ces fonctions est la mise en qualité de la base en détectant de potentielles erreurs de mesures ou de saisie.

Les fonctions de mise en forme du jeu de données en vue de son traitement sont préfixées par `mef_`.

# Grandes lignes de l'analyse

## Principe

Le point de départ est l'hypothèse classique selon laquelle l'équation qui permet de relier la longueur d'un poisson à son poids est de la forme :

<div align="center">

$Poids=a\cdot Longueur^b$

</div>

Les valeurs des coefficients $a$ et $b$ dépendent des unités qui sont, dans Aspe, les grammes et les millimètres.

Pour déterminer les valeurs des coefficients sur un jeu de données, les deux termes de l'égalité sont log-transformés pour prendre la forme :

<div align="center">

$\log(Poids)=\log(a)+b\cdot log(Longueur)$

</div>

Il suffit d'effectuer la régression linéaire de $\log(Poids)$ en fonction de $log(Longueur)$, de récupérer les coefficients $\alpha=\log(a)$ et $\beta=b$, puis de calculer $a=e^{\alpha}$.

## Contraintes sur le jeu de données

L'analyse reposant sur la régression entre deux grandeurs, il est nécessaires que ces deux grandeurs :

- Soient mesurées avec une précision suffisante
- Présentent une certaine variabilité
- Soient mesurées sur un nombre suffisant d'individus

Il faut aussi que les distributions des deux variables soient "raisonnablement" proches d'une gaussienne une fois log-transformées en particulier pour éviter que de potentiels *outliers* ne perturbent la relation générale.

## Chargement packages et données

```{r, eval = FALSE}
library(aspe)
library(tidyverse)

load(file = "processed_data/tables_sauf_mei_2021_09_10_14_35_58.RData")
load(file = "processed_data/mei_2021_09_29_11_57_35.RData")
```

```{r, eval = TRUE, echo = FALSE}
library(aspe)
library(tidyverse)

load(file = "../processed_data/tables_sauf_mei_2021_09_10_14_35_58.RData")
load(file = "../processed_data/mei_2021_09_29_11_57_35.RData")
```

# Gammes de taille et de poids

La première étape, pour éviter que des *outliers* ne perturbent les analyses, est de définir pour chaque jeu de données sur une espèce des gammes de longueurs et de poids "plausibles" en dehors desquelles les observations seront excles pour effectuer la régression. Dans la base, les poids (masses) sont en grammes et les longueurs en millimètres.

## Le jeu de données

Dans cet exemple, toutes les mesures individuelles de la base sont prises en compte.

>NB : Pour produire des relations taille - poids spécifiques à une région, en théorie il suffit de procéder de même après avoir filtré la table `mesure_individuelle`. En pratique, certaines espèces rares (peu d'individus) ou de très petite taille (erreurs relatives importantes de mesure du poids) peuvent bloquer la procédure.

Pour constituer le jeu de données, les étapes sont :

- Création d'une table "passerelle" mettant en correspondance les sites, opérations, etc.   
- Ajout des lots de poissons et de leur type pour ne conserver que les mesures individuelles   
- Remplacement des codes espèces internes de la base par les codes à trois lettres   
- Ajout des mesures individuelles pour ne conserver que les mesures réelles et positives de longueur et masse   
- Sélection des variables à conserver et dédoublonnage   


```{r}
tp_data <- mef_creer_passerelle() %>% # création de la passerelle
  mef_ajouter_lots() %>% # ajout des lots
  mef_ajouter_type_lot() %>% # ajout du type de lot
  filter(tyl_libelle == "N") %>%  # type de lot correspondant aux mesures individuelles
  mef_ajouter_esp_code_alternatif() %>% # ajout des codes espèces à trois lettres
  mef_ajouter_mei() %>% # ajout mesures individuelles
  filter(mei_taille > 0 & # taille positive
         mei_poids > 0 & # poids positifs
         mei_mesure_reelle == "t") %>% # mesure réelle et non obtenue en "dégroupant" des lots  
  select(mei_id,
         lop_id,
         tlo_id,
         mei_taille,
         mei_poids,
         esp_code_alternatif) %>% 
  distinct() # dédoublonnage
```

Combien de couples de mesures par espèce ?

<div align="center">

```{r, class.source = 'fold-hide'}
tp_data %>% 
  group_by(esp_code_alternatif) %>% 
    tally() %>%
  ungroup() %>% 
  arrange(-n) %>% 
  as.data.frame() %>% 
  DT::datatable(rownames = FALSE,
                width = 300) %>% 
  DT::formatCurrency(columns = 'n',
                     currency = "",
                     interval = 3,
                     mark = " ",
                     digits = 0)
```

</div>

## Distribution des longueurs

La fonction `qtp_histo()` permet de produire les graphiques de distribution des variables de taille et de poids.

Choix d'une espèce.

```{r}
mon_espece <- "VAN"
```

Production du graphique.

```{r}
qtp_histo(df = tp_data,
          code_espece = mon_espece,
          variable = "mei_taille",
          x_max = 500)
```

## Détermination des seuils

Quelles sont les seuils de longueur probables pour la `r mon_espece`, avec une probabilité de 1% ?

Jeu de donnée de mon espèce :

```{r}
data_esp <- tp_data %>% 
  filter(esp_code_alternatif == mon_espece)
```

Application de la fonction `qtp_seuils()`. Elle retourne un objet contenant deux éléments qui sont les bornes supérieure et inférieure.

```{r}
seuils <- qtp_seuils(df = data_esp,
                     code_espece = mon_espece,
                     variable = "mei_taille",
                     seuil_densite = 0.01)

seuils
```

Interprétation : Pour les `r mon_espece`, avec une densité de probabilité de 1%, on considérera les individus inférieurs à `r seuils[1]`mm ou supérieurs à `r seuils[2]`mm avec une attention particulière, voire ils seront considérés comme les *outliers* et éliminés.

Pour accéder au seuil mini ou au maxi, on les sélectionne avec les chochets `[]` autour du numéro souhaité. Le première des valeurs est le mini.

```{r}
seuils[1]
```

La seconde est la maxi.

```{r}
seuils[2]
```

Bien sûr ces valeurs dépendent de la densité de probabilité.

```{r, class.source = 'fold-hide'}
probas <- c(0.1, 0.05, 0.01, 0.001)

map(.x = probas,
    .f = qtp_seuils,
    df = data_esp,
    code_espece = mon_espece,
    variable = "mei_taille") %>% 
  reduce(rbind) %>% 
  as.data.frame() %>% 
  purrr::set_names(c("mini", "maxi")) %>% 
  mutate(densite_proba = probas) %>% 
  select(densite_proba, everything()) %>% 
  knitr::kable(row.names = F, format = "html", table.attr = "style='width:40%;'")
```

Pour plus de détail sur la méthode sous-jacente, taper dans la console `get("compute_group", ggplot2::StatDensity)`.

# Relation taille - poids

La première partie de cette section va détailler pas à pas la procédure de détermination de la relation taille - poids pour une espèce. La seconde va montrer comment aller droit au but pour obtenir le résultat pour plusieurs espèces si l'on se satisfait des options par défaut et qu'aucune difficulté ne vient perturber les calculs.

>Les longueurs dans la base Aspe sont en *mm*, mais les courbes issues de la littérature et synthétisées dans [Fishbase](www.fishbase.se) sont pour des longueurs en *cm.* Afin que les deux soient comparables, nous choisissons ici de convertir les longueurs en *cm*.

```{r}
data_esp <- data_esp %>% 
  mutate(mei_taille = mei_taille / 10)
```


## Pour une espèce

### Sélection initiale des observations

Pour éviter que les relations taille - poids soient dégradées par des valeurs très peu probables, on les construit sur une gamme de données écartant les valeurs extrêmes.

Détermination des seuils.

```{r}
seuils_taille <- qtp_seuils(df = data_esp,
                            code_espece = mon_espece,
                            variable = "mei_taille")

seuils_poids <- qtp_seuils(df = data_esp,
                           code_espece = mon_espece,
                           variable = "mei_poids")

```

Filtrage en utilisant les seuils.

```{r}
tp_esp <- data_esp %>%
  filter(mei_taille > seuils_taille[1],
         mei_taille < seuils_taille[2], 
         mei_poids > seuils_poids[1],
         mei_poids < seuils_poids[2], 
         mei_poids >= 5) # en-dessous de 5g la balance est souvent imprécise
```

### Modèle préliminaire

On construit un premier modèle en sachant qu'il est potentiellement fortement influencé par quelques observations. Le but est d'identifier de telles observations pour si nécessaire les supprimer avant de construire de nouveau un modèle.

La fonction `lm()` du package `{stats}` permet de réaliser une régression du log du poids en fonction du log de la longueur.

```{r}
mod <- lm(log(mei_poids) ~ log(mei_taille),
          data = tp_esp)
```

Le modèle `mod` est un objet de classe "lm" (*linear model*). Pour en explorer le contenu, `names(mod)`. Pour en obtenir le résumé :

```{r}
summary(mod)
```

Pour obtenir les graphiques de diagnostic :

```{r}
plot(mod)
```

Malgré un r² ajusté de 0.93, l'ajustement est médiocre. Quelques *outliers* contribuent fortement au modèle. Ils ont un très fort 'bras de levier' (*leverage*) comme le montre le graphique du bas.

### Elimination des observations trop influentes

Pour évaluer l'influence de chacun des individus sur l'équation de la régression, on peut utiliser la [distance de Cook](https://fr.wikipedia.org/wiki/Distance_de_Cook). Une cote mal taillée consiste à considérer que si la distance de Cook d'une observation excède 4/N, avec N le nombre d'observations, il est préférable d'éliminer cette observation.

Ces distances sont obtenues en appliquant au modèle la fonction `cooks.distance()` du package `{stats}`. 

```{r}
dist_cook <- cooks.distance(mod)
seuil_cook <- 4 / nrow(tp_esp)

tp_esp <- tp_esp %>% 
  cbind(dist_cook) %>% # ajout de la colonne avec les distances
  filter(dist_cook < seuil_cook) # suppression des observations avec distance > 4/N
```

### Modèle final

On peut maintenant recommencer et déterminer la relation taille - poids sur les observations retenues.

```{r}
mod <- lm(log(mei_poids) ~ log(mei_taille),
          data = tp_esp)

summary(mod)

plot(mod)
```

```{r, echo = FALSE}
alpha <- mod$coefficients["(Intercept)"]
beta <- mod$coefficients["log(mei_taille)"]
```

Les coefficients du modèle sont :

```{r}
mod$coefficients
```


Au final, l'équation retenue est :

log(poids) = log(`r alpha`) + `r beta` x log(longueur), soit, en conservant pas mal de décimales :

Poids(g) = `r exp(alpha) %>% format(scientific = FALSE)` x Longueur(cm)^`r beta`^

Graphiquement, on peut représenter la relation avec des axes arithmétiques ou bien log-transformés. Les courbes en rouge indiquent les valeurs prédites par le modèle. Elles sont contenues dans le modèle et on y accède par `mod$fitted.values`. Comme le modèle prédit $\log(Poids)$, pour obtenir le poids prédit on applique une exponentielle avec la fonction `exp()`.

```{r, fig.width=9, class.source = 'fold-hide'}
tp_esp <- tp_esp %>% 
  cbind(predicted = exp(mod$fitted.values)) %>% # ajout des valeurs prédites
  arrange(mei_taille) # mise en ordre de taille (pour le geom_line())

# graphique en axes arithmétiques
gg1 <- ggplot(data = tp_esp,
              aes(x = mei_taille,
                  y = mei_poids)) +
  geom_point(size = 0.2) +
  geom_line(aes(y = predicted),
            col = "red",
            size = 1) +
  labs(x = "Longueur (mm)",
       y = "Masse (g)",
       title = mon_espece)

# graphique en axes log-log
gg2 <- gg1 +
  scale_x_log10() +
  scale_y_log10()

# assemblage des graphiques
ggpubr::ggarrange(gg1,
                  gg2,
                  nrow = 1)
```


## Pour un ensemble d'espèces

Il s'agit ici d'enchaîner "automatiquement" les étapes détaillées ci-dessus au moyen de la fonction `qtp_calcul()`.

Seules les espèces pour lesquelles une régression taille-poids a du sens doivent être conservées, faute de quoi il y a des risques d'erreurs.

Conversion des longueurs en *cm*.

```{r}
tp_data <- tp_data %>% 
  mutate(mei_taille = mei_taille / 10)
```

```{r}
resume <- qtp_resume_donnees(df = tp_data,
                             seuil_poids_absolu = 5)
```


```{r, class.source = 'fold-hide'}
resume %>% 
  mutate_if(is.numeric, round, 1) %>% 
  DT::datatable()
```

Les espèces pour lesquelles seuls quelques individus passent le seuil du poids minimum ne peuvent faire l'objet d'une analyse fiable. Sélectionons par exemple les espèces avec au minimum 20 individus dépassant le seuil.

```{r}
mes_especes <- resume %>% 
  filter(n_sup_seuil > 19) %>% 
  pull(esp_code_alternatif) %>% 
  as.character()

mes_especes
```

Au total, `r length(mes_especes)` espèces comptent suffisamment d'individus.

Application de la fonction `qtp_calcul()` aux espèces sélectionnées, passage en numérique de toutes les variables sauf `esp_code_alternatif` et tri par ordre croissant du nombre d'individus mesurés et pesés :

```{r}
tp <- qtp_calcul(df = tp_data,
                 especes = mes_especes) %>% 
  mutate(across(!esp_code_alternatif,
                as.numeric)) %>% 
  arrange(-n_ind)
```

Résultat avec un peu de mise en forme :

```{r, class.source = 'fold-hide'}
tp %>% 
  DT::datatable(rownames = FALSE,
                options = list(columnDefs = list(list(className = 'dt-center',
                                                      targets = 0:3)))) %>% 
  DT::formatRound(columns = c('a', 'b'), digits = 4) %>% 
  DT::formatRound(columns = c('r2_ajuste'), digits = 2) %>% 
  DT::formatRound(columns = c('taille_mini', 'taille_maxi', 'poids_mini'), digits = 1) %>% 
  DT::formatCurrency(columns = c('n_ind', 'poids_maxi'), currency = "",
                     interval = 3, mark = " ", digits = 0)
```

```{r, class.source = 'fold-hide'}
tp %>% 
  downloadthis::download_this(
    output_name = "taille_poids",
    output_extension = ".csv",
    button_label = "Télécharger le tableau en csv",
    button_type = "success",
    has_icon = TRUE,
    icon = "fa fa-save"
  )
```

### Exportation / sauvegarde

Pour une exploitation avec R :

```{r, eval = FALSE}
save(tp, file = "processed_data/tp.RData")
```

Pour une exploitation avec un tableur :

```{r, eval = FALSE}
write.csv2(tp, file = "processed_data/tp.csv", row.names = FALSE)
```

# Mise en perspective / Fishbase

<div align="center">

![](../assets/logo_fishbase.png)

</div>

Le package {rfishbase} ([Boettiger, Lang & Wainwright 2012](https://fishlab.ucdavis.edu/wp-content/uploads/sites/397/2011/01/BoettigerFishbase2012.pdf)) est une interface pour utiliser avec R les données compilées dans Fishbase sur plusieurs milliers d'espèces.

Il a été  et a largement enrichi depuis 2012 pour suivre les évolutions de Fishbase et est accompagné d'un [tutoriel](https://docs.ropensci.org/rfishbase). 

On peut donc comparer nos résultats avec des données de [Fishbase](www.fishbase.se). 

## Installation du package `{rfishbase}`

Il faut d'abord charger le package {rfishbase} pour accéder à sa fonction `length_weight()`. 

```{r, eval = FALSE}
install.packages("rfishbase")
```

## Téléchargement des données Fishbase

Exemple avec la tanche, *Tinca tinca* (la fonction permettrait de charger les relations pour plusieurs espèces à la fois).

```{r}
nom_latin <- "Tinca tinca" # choix de l'espèce
fb_data <- rfishbase::length_weight(nom_latin) %>% 
  select(a,
         b,
         r2_ajuste = CoeffDetermination,
         n_ind = Number,
         taille_mini = LengthMin,
         taille_maxi = LengthMax,
         lieu = Locality)
```

Création d'un objet `lieu` pour localiser notre étude.

```{r}
lieu <- data.frame(lieu = "France - ASPE") 
```

Assemblage des tableaux. Il s'agit d'empiler nos résultats pour une espèce avec ceux de Fishbase. La présente étude figure sur la première ligne.

```{r}
synthese <- tp %>% 
  filter(esp_code_alternatif == "TAN") %>% # seulement la tanche
  cbind(lieu) %>% # ajout du lieu comme une colonne
  select(names(fb_data)) %>% # agencement des colonnes dans le même ordre que celles de fb_data
  rbind(fb_data) # empilement
```

Comme les intitulés des lieux d'étude sont assez moches (parfois les années, les coordonnées etc.) on peut les nettoyer un peu en utilisant la fonction `qtp_nettoyer_fb_lieu()` qui va supprimer dans la variable `lieu` les chiffres, les contenus entre parenthèses, les coordonnées ainsi que divers caractères spéciaux.

```{r}
synthese <- synthese %>% 
  qtp_nettoyer_fb_lieu()
```

Tableau mise en forme :

```{r, class.source = 'fold-hide'}
synthese %>% 
    DT::datatable(rownames = FALSE) %>% 
    DT::formatRound(columns = c('a', 'b'), digits = 4) %>% 
    DT::formatRound(columns = c('r2_ajuste'), digits = 2) %>% 
    DT::formatRound(columns = c('taille_mini', 'taille_maxi'), digits = 1) %>% 
    DT::formatCurrency(columns = c('n_ind'), currency = "",
                       interval = 3, mark = " ", digits = 0)
  
```


## Mise en perspective graphique

On peut reproduire le type de graphique que propose Fishbase pour situer les relations taille - poids les unes par rapport aux autres.

```{r, class.source = 'fold-hide'}
g <- ggplot(data = synthese, aes(x = b, y = log(a, base = 10), text = lieu)) +
  geom_point() +
  geom_point(data = synthese[1,], color = "red", size = 2) +
  geom_text(data = synthese[1,], color = "red", label = "France - Aspe", nudge_y = 0.07) +
  labs(y = "log10(a)", title = nom_latin)

plotly::ggplotly(g, tooltip="text")
```

Il est rassurant que notre point ne tombe pas totalement en dehors du nuage de points. Le point en bas à gauche est pour le moins douteux.

